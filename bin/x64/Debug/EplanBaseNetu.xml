<?xml version="1.0"?>
<doc>
    <assembly>
        "EplanBaseNet"
    </assembly>
    <members>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.ExitIdentityClient">
            <summary>
Exits Identity Client
</summary>
            <returns>IdentityClientResponse: operation result</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetConsentForUX">
            <summary>
Gets the consent for the UserExperience program
</summary>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.RequestUrlFromConfigurationService(Eplan.IdentityClient.ECloudConfiguration,System.String,System.String@)">
            <summary>
Requests ConfigurationServiceResponse from the ConfigurationService
</summary>
            <param name="configuration">Contains the EPLAN Cloud configuration. See GetConfiguration</param>
            <param name="strService">Name of the Service</param>
            <param name="strResult">Serialized result</param>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.CheckAuthenticationMessage">
            <summary>
Checks authentication messages
</summary>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.CheckAuthentication">
            <summary>
 Checks authentication results.
</summary>
 Checks authentication results
</member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.Signout">
            <summary>
Signs out
</summary>
            <returns>true if signout was successful otherwise false</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.StartAuthentication">
            <summary>
Starts authentication process
</summary>
            <returns>
true, if authentication succeeds or skipped. otherwise false.
If false is returned, the application should be terminated (Platform requirement)
</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.InitIdentityClient">
            <summary>
Inits IdentityClient 
</summary>
            <returns>IdentityClientResponse: operation result</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetServiceUrlFromCache(System.String,System.String@)">
            <summary>
Checks if the Dictionary already contains the Key and returns the serialized response in the referenced String
</summary>
            <param name="strKey">Key of the Dictionary</param>
            <param name="strResponse">The previous recieved serialized response result</param>
            <returns>bool: true if Response already in Dictionary</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetIdentityClientCookies(System.String@,System.String@)">
Internal methods
Following methods are intended to be called only from the Platform Framework or Unit tests
<summary>
Get IdentityClient Cookies
</summary><param name="strCookiesJson" /><param name="strUrl" /><returns>true if getting identity client cookies succeeded otherwise false</returns></member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetServiceUrl(System.String,System.String@)">
            <summary>
Gets Configuration service Url and Environment
</summary>
            <param name="strServiceName">EPLAN Cloud service name (apps, </param>
            <param name="strUrl">EPLAN Cloud service url</param>
            <returns>bool: true if success, otherwise false.</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetConfiguration(Eplan.IdentityClient.ECloudConfiguration@)">
            <summary>
Gets EPLAN Cloud Configuration: Environment:e.g. dev, devreview, devtopicx, prepord, prod, prodcn etc.),
								Configuration Service Url,
								Configuration Service Api Version: the version number of the Api (e.g. v1, v2, ...)
</summary>
            <param name="configuration">EPLAN Cloud configuration</param>
            <returns>bool: true if success, otherwise false.</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetHttpClient(System.String,System.String,System.Net.Http.HttpClient@)">
            <summary>
Gets HttpClient object.
A proxy for the baseAddress and the authorization header for the client strClientId are set by default in the
returned HttpClient object. In this way it is ready for use. 
</summary>
            <param name="strClientId">Client Id (e.g. PartsManagementClient is the client id for eStock)</param>
            <param name="url">Url for which a proxy object will be created and set in the HttpClient object</param>
            <param name="httpClient">valid HttpClient object. Note that this object should be created before calling this method.</param>
            <returns>IdentityClientResponse: operation result</returns>
            <summary>
Gets HttpClient object.
A proxy for the baseAddress and the authorization header for the client strClientId are set by default in the
returned HttpClient object. In tis way it is ready for use. 
</summary>
            <param name="strClientId">Client Id</param>
            <param name="url" />
            <param name="httpClient">valid HttpClient object if success otherwise null</param>
            <returns>IdentityClientResponse</returns>
Notice: Please avoid calling this Method in a loop. This could lead to network resource problems. You can call this methode once before starting the loop and inside
the loop you can refresh the acces_token by calling GetAccessToken() method which returns the refreshed access token und set it the HttpClient object created befor entring the loop. 
</member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetAccessToken(System.String)">
            <summary>
Gets AccessToken for a ClientId
After registration of the client id using RegisterClientId, one can utilize this method to
get an access token for a client id.
</summary>
            <param name="strClientId">Client Id (e.g. PartsManagementClient is the client id for eStock)</param>
            <returns>IdentityClientResponse: operation result. The access token is stored in the property AccessToken of this returned object.</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.RegisterClientId(System.String)">
            <summary>
Registers ClientId
By calling this method the internal TokenManagement will know about the client and manage access token for it.
After calling this method, one can utilize the method GetAccessToken or GetHttpClient for the registered client.
</summary>
            <param name="strClientId">Client Id (e.g. PartsManagementClient is the client id for eStock)</param>
            <returns>IdentityClientResponse: operation result</returns>
        </member>
        <member name="M:Eplan.IdentityClient.EIdentityClientService.GetUserProfile(Eplan.IdentityClient.CloudUserProfile@)">
            <summary>
Gets cloud user profile information
The returned CloudUserProfile object contains the user profile information such as DisplayName, OrganizationName, Email etc.
</summary>
            <param name="userProfile" />
            <returns>
true, if the user profile information could be provided.
false, if this method is called before user was signed in
</returns>
        </member>
        <member name="P:Eplan.IdentityClient.EIdentityClientService.SkipSignin">
            <summary>
Skips sign in
</summary>
        </member>
        <member name="P:Eplan.IdentityClient.EIdentityClientService.Authenticated">
            <summary>
Checks if user is authenticated
</summary>
        </member>
        <member name="P:Eplan.IdentityClient.EIdentityClientService.Signedout">
            <summary>
Checks if the user is signed out
</summary>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.ExecuteInMainThreadSync(Eplan.Net.ExecuteInEplanMainThreadDel3,System.Object)">
            <summary>
Execute this work in main thread. 
</summary>
            <exception cref="T:System.Exception">Thrown when no MainThreadDispatcher was set.</exception>
            <param name="pExecuteDelegate">The work to be done.</param>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.AddProgressBackgroundWork(EProgress*,Eplan.Net.BackgroundProgressWorkDel)">
            <summary>
Execute this work in background of a progress. 
</summary>
            <param name="pProgress">The Progress at work.</param>
            <param name="workDelegate">The work to be done.</param>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.ExecuteInMainThreadAsync(Eplan.Net.ExecuteInEplanMainThreadDel2,System.Object,System.Object)">
            <summary>
Execute this work in main thread. 
</summary>
            <exception cref="T:System.Exception">Thrown when no MainThreadDispatcher was set.</exception>
            <param name="pExecuteDelegate">The work to be done.</param>
            <param name="x">Parameter 1 for the work delegate</param>
            <param name="y">Parameter 2 for the work delegate</param>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.ExecuteInMainThreadAsync(Eplan.Net.ExecuteInEplanMainThreadDel1,System.Object)">
            <summary>
Execute this work in main thread. 
</summary>
            <exception cref="T:System.Exception">Thrown when no MainThreadDispatcher was set.</exception>
            <param name="pExecuteDelegate">The work to be done.</param>
            <param name="x">Parameter 1 for the work delegate</param>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.ExecuteInMainThreadAsync(Eplan.Net.ExecuteInEplanMainThreadDel)">
            <summary>
Execute this work in main thread. 
</summary>
            <exception cref="T:System.Exception">Thrown when no MainThreadDispatcher was set.</exception>
            <param name="pExecuteDelegate">The work to be done.</param>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.CanAccessMainThread">
            <summary>
Main Thread Accessed?
</summary>
            <exception cref="T:System.Exception">Thrown when no MainThreadDispatcher was set.</exception>
            <returns>
true then execution is possible.
</returns>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.GetMainThreadDispatcher">
            <summary>
Get the mainThreadDispatcher.
</summary>
            <returns>
The main thread dispatcher of this application
</returns>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.SetMainThreadDispatcher(System.Windows.Threading.Dispatcher)">
            <summary>
Set the mainThreadDispatcher once.
</summary>
            <param name="mainThreadDispatcher">The main thread dispatcher of this application</param>
        </member>
        <member name="M:Eplan.Net.EMainThreadDispatcher.#ctor">
            <summary>
Creates a new dispatcher
</summary>
        </member>
        <member name="T:Eplan.Net.EMainThreadDispatcher">
            <summary>
EMainThreadDispatcher can execute some work in the main thread of Eplan. The work
is done async, when the mainthread is currently waiting for a backgroundwork to be done.
</summary>
        </member>
        <member name="T:Eplan.Net.ExecuteInEplanMainThreadDel">
            <summary>
Delegate to give EMainThreadDispatcher some work.
</summary>
        </member>
        <member name="M:EIdentityClientServiceImpl.checkAuthentication">
 Checks authentication results.
</member>
        <member name="M:AfLc.isLicensingAvailable">
Checks if licensing is available
</member>
        <member name="F:AfLcData.m_bIsLicensingAvailable">
is licensing is available
</member>
        <member name="F:AfApplication.m_bIdentityClientInitialized">
************************************************************************
************************************************************************
</member>
        <member name="M:AfApplication.signout">
Internal methods
Following methods are intended to be called ONLY by the Platform Framework or Unit tests
</member>
        <member name="M:IEIdentityClientService.signout">
Signs out user
</member>
        <member name="M:IEIdentityClientService.startAuthentication">
Internal methods
Following methods are intended to be called ONLY by the Platform Framework or Unit tests
</member>
        <member name="M:IEIdentityClientService.getAccessToken(EString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets AccessToken for a ClientId
</member>
        <member name="M:IEIdentityClientService.registerClientId(EString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Registers ClientId
</member>
        <member name="M:IEIdentityClientService.getConsentForUX">
Gets consent for the user experience program
</member>
        <member name="M:IEIdentityClientService.getUserProfile(EPulseUserProfile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets user profile
</member>
        <member name="M:IEIdentityClientService.getSkipSigninFlag">
Gets skip sign in flag
</member>
        <member name="M:IEIdentityClientService.setSkipSigninFlag(System.Boolean)">
Sets skip sign in flag
</member>
        <member name="M:IEIdentityClientService.isUserAuthenticated">
Checks if user is authenticated
</member>
        <member name="M:IEIdentityClientService.getSignedoutFlag">
Gets Signed out flag
</member>
        <member name="M:IEIdentityClientService.setSignedoutFlag(System.Boolean)">
Sets Signed out flag
</member>
        <member name="T:boost.mpl.less_impl{boost.mpl.na,boost.mpl.na}">
for Digital Mars C++/compilers with no CTPS/TTP support
</member>
        <member name="T:boost.mpl.times_impl{boost.mpl.na,boost.mpl.na}">
for Digital Mars C++/compilers with no CTPS/TTP support
</member>
        <member name="T:boost.mpl.equal_to_impl{boost.mpl.na,boost.mpl.na}">
for Digital Mars C++/compilers with no CTPS/TTP support
</member>
        <member name="M:op_BitwiseAnd(IEArchive*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
global operator to write an EColor into an archive or to read it from
</member>
        <member name="M:EBox3D.getCenter">
get box center point 
</member>
        <member name="M:EBox3D.getDiagonal">
get box direction vector.
</member>
        <member name="M:EPosition3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion from eCabinet/Triga
</member>
        <member name="M:EPosition3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
explicit set
</member>
        <member name="M:EPosition3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion from eCabinet/Triga
</member>
        <member name="M:EPosition3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
explicit constructor
</member>
        <member name="M:EPosition3D.#ctor(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion from ETransform3D
</member>
        <member name="M:EPosition3D.#ctor(EPosition3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EPosition3D.#ctor(EPosition3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EPosition3D.#ctor">
default constructor
</member>
        <member name="F:EArc3D.m_Angle">
angle to End-Point
</member>
        <member name="F:EArc3D.m_StartVector">
Start-Point
</member>
        <member name="F:EArc3D.m_Normal">
normal vector 
</member>
        <member name="F:EArc3D.m_Origin">
center point
</member>
        <member name="M:EArc3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Methodes from Interface ICurve3D
	@see : ICurve3D

</member>
        <member name="M:EPath3D.getEndPoint">
Interface Function
</member>
        <member name="M:EPath3D.getStartPoint">
Interface Function
</member>
        <member name="M:EPath3D.isClosed">
Interface Function
</member>
        <member name="M:EContour3D.triangulate(std.vector&lt;ETriangle3D,std.allocator&lt;ETriangle3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
triangulate closed contour
</member>
        <member name="M:EContour3D.getEndPoint">
Interface Function
</member>
        <member name="M:EContour3D.getStartPoint">
Interface Function
</member>
        <member name="M:EContour3D.isClosed">
Interface Function
</member>
        <member name="T:EPointArray3D">
represents an array of points

</member>
        <member name="M:EBoundingBox3D.checkBoxZRange(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
special Function to compare the Z-range of two bounding boxes. 
Needed for hidden line calculation.
returns a negative value if this Z-range is closer to 0 than bb
returns 0 if Z-ranges overlap
returns a positive value if bb Z-range is closer to 0 than this 

</member>
        <member name="M:EBoundingBox3D.isInsideBoxXY(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
special Function to compare two bounding boxes by ignoring z-axis. 
Needed for hidden line calculation.
True if this is inside or touching bb
False if this and bb are disjunct. 

</member>
        <member name="M:EBoundingBox3D.isInside(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
special function for polygon inside/outside test:
		return value is true if point is inside, else
		LowCount is increased, if p is left, lower, nearer then LDF
		HighCount is increased, if p is right, upper, farer then RUB

</member>
        <member name="M:EBoundingBox3D.getSize">
returns getLength(GetDiagonale())
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getCenter">
returns getRub()-getLdf()/2
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getDiagonal">
returns getRub()-getLdf()
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRub">
returns right, up back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRuf">
returns right, up, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRdb">
returns right, down, back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRdf">
returns right, down, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLub">
returns left, up, back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLuf">
returns left, up, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLdb">
returns left, down, back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLdf">
returns left, down, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.isSet">
check, if at least one point was set (is false after clear)
</member>
        <member name="M:EBoundingBox3D.merge(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
adds another BoundingBox
</member>
        <member name="M:EBoundingBox3D.merge(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
adds one Point
</member>
        <member name="M:EBoundingBox3D.clear">
initializes the BoundingBox empty
</member>
        <member name="M:EBoundingBox3D.set(ERectangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
initializes the BoundingBox whith a 2D rectangle and the z range
</member>
        <member name="M:EBoundingBox3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox whith to corner points
</member>
        <member name="M:EBoundingBox3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox as a cube with edges of "size" length
</member>
        <member name="M:EBoundingBox3D.set(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox by another BoundingBox
</member>
        <member name="M:EBoundingBox3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox with one point (size()=0)
</member>
        <member name="M:EPlane3D.getDirectedDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
distance in direction of normal is positive, other side negative
this value will be negative(!) if the point is opposite to the nomal of the plane
</member>
        <member name="M:EPlane3D.intersect(EPlane3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ERay3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
intersect Plane with plane; result is a ray 
</member>
        <member name="M:EPlane3D.intersect(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
intersect ray with plane
</member>
        <member name="M:EPlane3D.project(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
projected vector on plane
</member>
        <member name="M:EPlane3D.project(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
projected point on plane
</member>
        <member name="M:EPlane3D.getPointFromPlane(EPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plane coordinates to world
</member>
        <member name="M:EPlane3D.getPointOnPlane(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
World coordinates to plane, true if exact on plane, else projected point
</member>
        <member name="M:EPlane3D.getDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and Plane
</member>
        <member name="M:EPlane3D.getDistanceSq(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and Plane
</member>
        <member name="M:EPlane3D.transform(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform plane
</member>
        <member name="M:EPlane3D.isOn(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if ray is flat in the plane
</member>
        <member name="M:EPlane3D.isOn(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if vector is flat in the plane
</member>
        <member name="M:EPlane3D.isOn(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if point is on Plane
</member>
        <member name="M:EPlane3D.isParallel(EPlane3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
check for parallel Planes, true if normals are colinear 
</member>
        <member name="M:EPlane3D.op_Equality(EPlane3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plane equality operator.
</member>
        <member name="M:EPlane3D.getAxisV">
Plane V-Axis (calculated from normal)
</member>
        <member name="M:EPlane3D.getAxisU">
Plane U-Axis (calculated from normal)
</member>
        <member name="M:EPlane3D.getOrigin">
Plane getOrigin
</member>
        <member name="M:EPlane3D.getNormal">
Plane normal vector.
</member>
        <member name="M:ERay3D.rayDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
pkt is projected orthogonal to the ray. then the directed distance between the ray origin and this projection is calculated
	this is reverse to getPoint(dbl); 

pkt is projected orthogonal to the ray. then the directed distance between the ray origin and this projection is calculated
</member>
        <member name="M:ERay3D.rayDistanceSq(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates distance between two rays
if result ==0.0, rays intersect, result has coordinates of the intersection point
if result &gt;0.0, the rays don't intersect, result has coordinates of the point of minimal distance on ray1.

</member>
        <member name="M:ERay3D.projectTo(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate closest point to given Point
</member>
        <member name="M:ERay3D.getDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and ray
</member>
        <member name="M:ERay3D.getDistanceSq(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and Plane
</member>
        <member name="M:ERay3D.transform(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform ray
</member>
        <member name="M:ERay3D.isOn(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
ray is on 
</member>
        <member name="M:ERay3D.isParallel(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
check for parallel rays, true if directions are collinear 
</member>
        <member name="M:ERay3D.op_Equality(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
ray equality operator.
</member>
        <member name="M:ERay3D.getOrigin">
ray origin
</member>
        <member name="M:ERay3D.getDirection">
ray direction vector.
</member>
        <member name="M:ERay3D.setOrigin(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ray getOrigin
</member>
        <member name="M:ERay3D.setDirection(EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ray direction vector.
</member>
        <member name="M:ERay3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
</member>
        <member name="M:EUnitVector3D.normalizedScalarprod(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates scalarproduct with unit vectors
</member>
        <member name="M:EUnitVector3D.unit">
normalize to unit length
</member>
        <member name="M:EUnitVector3D.getLength">
get length
</member>
        <member name="M:EUnitVector3D.getLengthSq">
get square of length
</member>
        <member name="M:EUnitVector3D.op_SubtractionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace subtract a vector
</member>
        <member name="M:EUnitVector3D.op_AdditionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add a vector
</member>
        <member name="M:EUnitVector3D.op_DivisionAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
divide by a scale
</member>
        <member name="M:EUnitVector3D.op_MultiplicationAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
multiplicate inplace by a scalar
</member>
        <member name="M:EUnitVector3D.set(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ordinates
</member>
        <member name="M:EUnitVector3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EUnitVector3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EUnitVector3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EContour2D.addSegmentBegin(EPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Alias of addSegmentPoint
</member>
        <member name="M:ETransform3D.getMov">
access to transformation vector component of the transformation
</member>
        <member name="M:ETransform3D.getMat">
access to rotation matrix component of the transformation
</member>
        <member name="M:ETransform3D.getScale">
calculates the scale of a 3D-transform. is the 3.root of getDeterminante
	does not work properly, if scaling for x y and z is different 
</member>
        <member name="M:ETransform3D.isMirror">
returns true, if the transformation does mirror objects
</member>
        <member name="M:ETransform3D.getDeterminante">
calculates the determinant of the matrix
</member>
        <member name="M:ETransform3D.transpose">
transpose Matrix (swap columns and rows)
</member>
        <member name="M:ETransform3D.op_UnaryNegation">
build inverse transform 
</member>
        <member name="M:ETransform3D.op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform distance (eg. radius); does not work properly if scaling in x,y and z is different
</member>
        <member name="M:ETransform3D.transform(EVector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a vector inplace

transform a vector inplace
</member>
        <member name="M:ETransform3D.transform(EPoint3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a pointvector inplace

transform a pointvector inplace
</member>
        <member name="M:ETransform3D.op_Multiply(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a pointvector
</member>
        <member name="M:ETransform3D.op_Multiply(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a vector
</member>
        <member name="M:ETransform3D.op_MultiplicationAssignment(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
in place combine two transformation by matrix multiply
</member>
        <member name="M:ETransform3D.op_Multiply(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
combine two transformation by matrix multiply
</member>
        <member name="M:ETransform3D.op_Equality(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test equality

test equality
</member>
        <member name="M:ETransform3D.setIdentity">
build identity transform
</member>
        <member name="M:ETransform3D.op_Assign(ETransform3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
move operator
</member>
        <member name="M:ETransform3D.op_Assign(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
assignment operator
</member>
        <member name="M:ETransform3D.#ctor(EMatrix3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a from values
</member>
        <member name="M:ETransform3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a translating ETransform3D
</member>
        <member name="M:ETransform3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation ETransform3D, that rotates counter clock wise around the given center point and axis
</member>
        <member name="M:ETransform3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a ETransform3D, from two axis and an origin point
</member>
        <member name="M:ETransform3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a ETransform3D from two axis, calculates w = u%v
</member>
        <member name="M:ETransform3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a ETransform3D from three axis
</member>
        <member name="M:ETransform3D.#ctor(System.Double)">
constructs a scaling ETransform3D
</member>
        <member name="M:ETransform3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation ETransform3D by three angles 
</member>
        <member name="M:ETransform3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation ETransform3D by axis and angle
</member>
        <member name="M:ETransform3D.#ctor(ETransform3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the move constructor
</member>
        <member name="M:ETransform3D.#ctor(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the copy constructor
</member>
        <member name="M:ETransform3D.#ctor">
constructs a unit transform
</member>
        <member name="M:EMatrix3D.op_MultiplicationAssignment(EMatrix3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
in place combine two transformation by matrix multiply
</member>
        <member name="M:EMatrix3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.">
constructs a from values
</member>
        <member name="M:EMatrix3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a scaling matrix
</member>
        <member name="M:EMatrix3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation matrix by three angles 
</member>
        <member name="M:EMatrix3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation matrix by axis and angle
</member>
        <member name="M:EMatrix3D.#ctor(EMatrix3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the copy constructor

the move constructor
</member>
        <member name="M:EMatrix3D.#ctor">
constructs a unit matrix
</member>
        <member name="M:EVector3D.getV">
get as array of doubles 
</member>
        <member name="M:op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
friend operator, first operand not a W3dGeometry class 
skalar multiplication

skalar multiplication
</member>
        <member name="M:EVector3D.normalizedCrossprod(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates cross product with unit vectors
</member>
        <member name="M:EVector3D.normalizedScalarprod(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates scalarproduct with unit vectors
</member>
        <member name="M:EVector3D.getAngle(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate angle between vectors (0-360°), plane normal vector decides what is the right angle
</member>
        <member name="M:EVector3D.getAngleXY(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate angle between vectors (0-180°)
</member>
        <member name="M:EVector3D.getAngle(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate angle between vectors (0-180°)
</member>
        <member name="M:EVector3D.isNull">
faster test if getLength() equals 0.0
</member>
        <member name="M:EVector3D.isColinear(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if two Vectors are colinear 
</member>
        <member name="M:EVector3D.unit">
normalize to unit length
</member>
        <member name="M:EVector3D.getLength">
get length
</member>
        <member name="M:EVector3D.getLengthSq">
get square of length
</member>
        <member name="M:EVector3D.op_Inequality(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test unequal; to bee implemented if needed 
</member>
        <member name="M:EVector3D.op_Equality(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test equal
</member>
        <member name="M:EVector3D.op_UnaryNegation">
negate a vector
</member>
        <member name="M:EVector3D.op_Modulus(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
vector product
</member>
        <member name="M:EVector3D.op_Subtraction(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
subtract a vector
</member>
        <member name="M:EVector3D.op_Addition(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
add a vector
</member>
        <member name="M:EVector3D.op_Multiply(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
scalar product
</member>
        <member name="M:EVector3D.op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
multiplicate by a scalar
</member>
        <member name="M:EVector3D.op_SubtractionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace subtract a vector
</member>
        <member name="M:EVector3D.op_AdditionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add a vector
</member>
        <member name="M:EVector3D.op_DivisionAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
divide by a scale
</member>
        <member name="M:EVector3D.op_MultiplicationAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
multiplicate inplace by a scalar
</member>
        <member name="M:EVector3D.set(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ordinates
</member>
        <member name="M:EVector3D.getAt(System.UInt32)">
get cordinate at index (0, 1 or 2)

get coordinate 
</member>
        <member name="M:EVector3D.setZ(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set z coordinate

set z coordinate
</member>
        <member name="M:EVector3D.getZ">
get z coordinate

get z coordinate
</member>
        <member name="M:EVector3D.setY(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set y coordinate

set y coordinate
</member>
        <member name="M:EVector3D.getY">
get y coordinate

get y coordinate
</member>
        <member name="M:EVector3D.setX(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set x cordinate

set x cordinate
</member>
        <member name="M:EVector3D.getX">
get x cordinate

get x cordinate
</member>
        <member name="M:EVector3D.init">
clear content

clear content
</member>
        <member name="M:EVector3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion constructor: treat point as vector
</member>
        <member name="M:EVector3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EVector3D.#ctor(EVector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
move constructor
</member>
        <member name="M:EVector3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EVector3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EVector3D.#ctor">
default constructor
</member>
        <member name="M:EPoint3D.getAt(System.UInt32)">
get coordinate 
</member>
        <member name="M:EPoint3D.getV">
get Point as array of doubles 

get as array of doubles 
</member>
        <member name="M:EPoint3D.distanceTo(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates distance 
</member>
        <member name="M:EPoint3D.distanceSqTo(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates square of distance (faster than calc distance)
</member>
        <member name="M:EPoint3D.setZ(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set z coordinate

set z coordinate
</member>
        <member name="M:EPoint3D.z">
get z coordinate

get z coordinate
</member>
        <member name="M:EPoint3D.setY(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set y coordinate

set y coordinate
</member>
        <member name="M:EPoint3D.y">
get y coordinate

get y coordinate
</member>
        <member name="M:EPoint3D.setX(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set x cordinate

set x cordinate
</member>
        <member name="M:EPoint3D.x">
get x cordinate

get x cordinate
</member>
        <member name="M:EPoint3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion constructor
</member>
        <member name="M:EAngleType.op_UnaryNegation">
invert angle
</member>
        <member name="M:EAngleType.op_SubtractionAssignment(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add angles 
</member>
        <member name="M:EAngleType.op_Subtraction(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
add angles 
</member>
        <member name="M:EAngleType.op_AdditionAssignment(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add angles 
</member>
        <member name="M:EAngleType.op_Addition(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
add angles 
</member>
        <member name="M:EAngleType.value(enAngleType,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle specifyed unit
</member>
        <member name="M:EAngleType.value(enAngleType)">
get Angle specifyed unit
</member>
        <member name="M:EAngleType.trn">
get Angle in turns; circle=1
</member>
        <member name="M:EAngleType.rad">
get Angle in radian; circle=2*PI
</member>
        <member name="M:EAngleType.deg">
get Angle in degrees; circle=360deg
</member>
        <member name="M:EAngleType.trn(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle in turns; circle=1
</member>
        <member name="M:EAngleType.rad(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle in radian; circle=2*PI
</member>
        <member name="M:EAngleType.deg(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle in degrees; circle=360deg
</member>
        <member name="M:EAngleType.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EAngleType.#ctor(enAngleType,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EAngleType.#ctor">
default constructor
</member>
        <member name="T:enAngleType">
Type to define angle value range
</member>
        <member name="F:AT_TURNS">
circle 1.0
</member>
        <member name="F:AT_RADIAN">
circle 2*PI
</member>
        <member name="F:AT_DEGREE">
circle 360°
</member>
    </members>
</doc>